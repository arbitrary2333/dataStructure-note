1、排序算法：冒泡、选择、插入、归并、计数、基数、希尔、堆、桶排序
    简单排序：冒泡排序、选择排序、插入排序
    高级排序：希尔排序、快速排序
2、冒泡排序：
    效率较低、实现简单
    依次比较相邻两个元素的大小，将较大的数放到后面，较小的数放到前面，最后最大的数就会放在最后面，依此类推
    比较次数：o(N^2)
    交换次数：o(N^2)
3、选择排序：
    效率比冒泡高
    选定第一个元素的索引并保存，然后和后面元素依次进行比较，碰到比自身小的将索引重新赋值，最后将第一个元素与索引指向的元素互换，就能得到最小的元素了，依此类推
    比较次数：o(N^2)
    交换次数：o(N)
4、插入排序
    学习其他高级排序的基础
    插入排序的核心是局部有序，适用于已经有序或基本有序的情况
    从第一个元素开始，该元素可被认为已排序，然后取出下一个元素，在已经排序的序列中从后向前扫描，直到找到小于或者等于该元素的新元素，将新元素插入到该位置上，重复上面的操作即可
    插入排序应该从下标1开始
    比较次数：选择排序的一半( N*(N-1) / 4 )  o(N^2)
    复制次数(复制比交换效率高)： 选择排序的一半( N*(N-1) / 4 ) o(N^2)
5、希尔排序
    希尔排序是插入排序的改进版，并且比插入排序效率更快
    希尔排序出现之前排序算法时间复杂度都是o(N^2)，终于有一天希尔超越了o(N^2)
    插入排序的问题：当一个很小的数据在靠近右端的位置，插入排序就会将其依次与前面的元素比较，比较消耗性能
    选取数据量一半的长度作为分组间隔，将其进行一一分组，并对其进行插入排序，然后将分组间隔再减半，依此类推，直至执行完分组间隔为1时，排序完成
    希尔排序的效率与增量有关，效率证明非常困难
    时间复杂度：o(N^2),通常情况下要好于o(N^2)
6、快速排序
    快速排序几乎是所有排序算法中效率最高的，当然没有任何一种算法在任意情况下都是最优的
    快速排序的应用：C++的STL，JAVA的SDK
    快速排序也被称为20世纪十大算法之一
    快速排序是冒泡排序的升级版，快速排序可以在一次排序中找到元素的正确位置，并且该元素在之后不需要任何移动
    快速排序的最重要思想是分而治之
    对头中尾三个元素进行排序，并将其中位数放置在倒数第二的位置上，设立left与right分别指向第一个元素和倒数第二个元素，left与中位数比较，如果比中位数小，将left向右移动指向下一个元素，依次类推，直至大于中位数时left暂停，right比中位数小时right暂停，都暂停后将left与right交换，然后继续向中间聚集，直至left = right，将中位数与left交换，然后对该中位数左侧与右侧进行相同操作，最后完成排序
    选择枢纽的方法：a、直接选择第一个元素作为枢纽，但某些情况下效率不高；b、随机数，但随机数本身就是一个耗性能的操作；c、取头、中、尾的中位数
    快速排序最坏情况：每次选择的枢纽都是最左边或者最右边的
    时间复杂度：o(N*logN)
7、通常情况下排序的效率比较
    低--->高
    冒泡 < 选择 < 插入 < 希尔 < 快速
8、常见大O表示形式
    o(1) ---> 常数的
    o(log(N)) ---> 对数的
    o(N) ---> 线性的
    o(Nlog(N)) ---> 线性和对数乘积
    o(N^2) ---> 平方
9、推导大O表示法的方式
    a、用常量1取代运行时间中所有的加法常量
    b、在修改后的运行次数函数中，只保留最高次项
    c、如果最高存在且不为1，则去除与这个项相乘的常数