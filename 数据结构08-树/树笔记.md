1、数组
    优点：
        查找效率高，可根据下标值直接访问
    缺点：
        根据元素获取相应位置较为麻烦，比较好的方式为先对数组进行排序，再进行二分查找
        插入和删除效率低，在插入和删除时，需要有大量的位移操作，插入到首位或中间的位置
2、链表
    优点：
        插入和删除效率高
    缺点：
        查找效率低，需要从头或者从尾部开始访问链表中的数据项，如果该元素在中间位置查找效率会很低
        插入和删除中间位置元素时还是需要从头先找到对应数据
3、哈希表
    优点：
        插入查询删除效率很高
    缺点：
        空间利用率不高，底层使用的是数组，并且某些单元是没有被利用的
        哈希表的元素是无序的，不能按照固定的顺序来遍历哈希表中的元素
        不能快速的找到哈希表中的最大值或者最小值
4、树
    优点：
        树结构综合了上面的数据结构的优点（当然有点不足以盖过其他数据结构，比如效率一般其情况下没有哈希表高）
        非线性结构
        可以表示一对多的关系
5、树的术语
    树(Tree)：n(n>=0)个节点构成的有限集合
        空树：n=0时，称为空树
        根(Root)：树中有一个称为根(Root)的特殊节点，用r表示，在树最开始的节点位置
        子树：根节点下其余节点也可分为m(m>0)个互不相交的有限集T1,T2...,Tm，其余每个集合又是一棵树，称为原来树的“子树”
    节点的度(Degree)：节点的子树的个数
    树的度：树的所有节点中最大的度数
    叶节点(Leaf)：度为0的节点（也成为叶子节点）
    父节点(Parent)
    子节点(Child)
    兄弟节点(Sibling)
    路径和路径长度：从节点n1到nk的路径为一个节点序列n1,n2,...,ni,其中ni是ni+1的父节点。路径所包含边的个数为路径的长度
    节点的层次(Level)：规定根节点在1层，其它任一节点的层数是其父节点的层数加1
    树的深度(Depth)：树中所有节点的最大层次是这棵树的深度
6、树的表示（任何一颗树都可以用二叉树模拟出来）：
    普通表示法：指向多少节点就分几个节点指向
    儿子兄弟表示法：只有左右节点，左节点指向它的子节点，右节点指向它的兄弟节点
7、二叉树：
    概念：如果树中每个节点最多只能有两个子节点，这样的树就称为二叉树
    二叉树特性（面试题常考*）：
        一个二叉树第i层的最大节点数为：2^(i-1)，i>=1；
        深度为k的二叉树有最大节点总数为：2^k-1，k>=1；
        对任何非空二叉树T，若n0表示叶节点的个数，n2表示度为2的非叶节点个数，那麽就会有n0=n2+1
    完美二叉树（满二叉树）：在二叉树中，除了最下一层的叶子节点外，每层节点都有2个子节点，就构成了满二叉树
    完全二叉树（Complete Binary Tree）：
        除二叉树最后一层外，其他各层的节点数都达到最大个数
        且最后一层从左向右的叶节点连续存在，只缺右侧若干节点
        完美二叉树又是特殊的完全二叉树
    二叉树存储：常见的方式是数组和链表
        使用数组：按从上到下、从左到右顺序存储，非完全二叉树要转换成完全二叉树才可按此方案存储，但会造成很大的空间浪费
8、二叉搜索树（BST，Binary Search Tree，也称为二叉排序树或二叉查找树）
    二叉搜索树是一颗二叉树，可以为空
    性质：
        非空左子树的所有键值小于其根节点的键值
        非空右子树的所有键值大于其根节点的键值
        左、右子树本身也是一个二叉搜索树
    特点：
        较小的值总是保存在左节点上，较大的值总是保存在右节点上
        查找效率非常高，这也是二叉搜索树中“搜索”的由来
    二分查找（二叉搜索树的思想）
    二叉搜索树有哪些常见的方法：
        insert(key)：向树中插入一个新的键--->运用了递归
        search(key)：在树中查找一个键，如果节点存在，则返回true，反之false
        inOrderTraverse：通过中序遍历方式遍历所有节点
        preOrderTraverse：通过先序遍历方式遍历所有节点
        postOrderTraverse：通过后序遍历方式遍历所有节点
        min：返回树中最小的值
        max：返回树中最大的值
        remove(key)：丛树中移除某个键
    二叉搜索树的遍历（递归访问）（个人理解：先想出递归后的函数，在从最深处开始向外层逐步推导）
        先序遍历：
            访问其根节点
            先序遍历其左子树
            先序遍历其右子树
        中序遍历:
            先序遍历其左子树
            访问其根节点
            先序遍历其右子树
        后序遍历:
            先序遍历其左子树
            先序遍历其右子树
            访问其根节点
        (还有程序遍历)
    二叉搜索树的删除
        情况一：该节点是叶节点，直接放置
        情况二：该节点有一个子节点，直接删除该节点并将其子节点放到该节点上
        情况三：该节点有两个子节点
            如果我们要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下我们需要从下面的节点中找到一个节点（前驱或后继都可），来替换当前的节点
            前驱：比current小一点点的节点，一定是current左子树的最大值
            后继：比current大一点点的节点，一定是current右子树的最小值
    二叉树的缺陷（面试考）：
        当二叉树插入连续的一组数据后，在树中就会向一端无限延伸，形成一个链表，插入和查找的效率就会变低
    非平衡树：
        定义：比较好的二叉搜索树是左右分布均匀的，但是插入连续数据后，分布的不均匀，我称这种树为非平衡树
        效率：对于一个平衡二叉树来说，插入和查找等操作的效率是O(logN)
            对于一个非平衡二叉树来说，相当于编写了一个链表，查找效率变成了O(N)
        怎末保持树的平衡呢？AVL树，红黑树
9、红黑树（原理常考）
    规则：
        节点是红色或黑色
        根节点是黑色
        每个叶子节点都是黑色的空节点（NIL节点）
        每个红色节点的两个子节点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）
        从任一节点到每个叶子的所有路径都包含相同数目的黑色节点
    红黑树的相对平衡：从根节点到叶子结点的最长可能路径，不会超过最短可能路径的2倍，结果就是这个树基本是平衡的
    插入一个新节点，有可能树不再平衡，可以通过三种方式的变换，让树保持平衡（让红黑树保持平衡的方式）：变色————左旋转————右旋转
        变色：
            插入一个新节点时，我们通常会选择什么颜色插入？
                选择插入红色节点。因为在插入节点为红色的时候，有可能插入一次是不违反红黑树规则的，而插入黑色节点，必然会导致有一条路径上多了黑色节点，这是很难调整的，红色节点可能会出现红红相连的情况，这种情况可以通过颜色调换和旋转来调整
        左旋转：逆时针旋转红黑树两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子
        右旋转：顺时针旋转红黑树两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子
            如果他们有子树是否会影响旋转？不会！
    红黑树的插入操作（分为五种情况）：
        假设：要插入的节点为N，其父节点为P，其祖父节点为G，其父亲的兄弟节点为U
        情况一：新节点N位于树的根上，没有父节点，这种情况下，我们直接将红色变换成黑色即可
        情况二：新节点的父节点是黑色，不用变换
        情况三：父红叔红祖黑-->父黑叔黑祖红，如果祖父节点的父节点为红色，则需要递归处理
        情况四：父红叔黑祖黑，N是左儿子-->父黑，祖红，右旋转
        情况五：父红叔黑祖黑，N是右儿子-->以P为根进行左旋转，将P作为新插入的红色节点考虑即可，自己变成黑色，祖变成红色，以祖为根进行右旋转（左旋转后与情况四一致）
    案例：插入10，9，8，7，6，5，4，3，2，1
        注意：在插入7时会进行情况三的变换，这时根节点为红色不符合规则二，进而将其在转换为黑色
              在插入3时符合情况三，但是会有两个连续的红色节点，此时须将5看成整体，又符合情况四，变换后即可
              在插入1时也会遇到符合情况三但需要二次变换的情况，但二次变换仍符合情况三