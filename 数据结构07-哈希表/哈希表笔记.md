1、哈希表介绍（个人理解：字符串转下标，一种映射关系）：
    JS的Object对象是基于哈希表实现，几乎所有的编程语言都有直接或间接地应用这种数据结构
    哈希表通常是基于数组实现的
    哈希表的优势：
        提供非常快速的插入-删除-查找操作（比树还要快，效率接近O(1)）
        相对于树编码容易
    哈希表的不足：
        没有顺序，不能以一种固定的方式遍历
        key不允许重复（集合和字典通常也是基于哈希表实现）
    数组的优劣势：
        数组再插入操作时，效率比较低
        数组在进行查找的效率
            基于索引查找，效率非常高
            基于内容查找，效率比较低
        数组进行删除操作，效率也不高
    使用哈希表的案例：
        公司员工存储：
            数组存储：如通过员工姓名查找对应信息时需从头开始遍历相对麻烦
            链表存储：插入和删除有一定优势，但获取员工信息也需要从头或从尾部开始遍历
            哈希表存储：当我们使用数组时想查找一个员工的信息时我们不知道员工的编号，该怎末办呢？有一种办法是让员工姓名和编号产生直接的关系，我们通过姓名获取到它的索引值，再通过索引值查找到该员工的信息，这就是哈希函数
        联系人和电话存储
        50000个单词存储
    字符串转下标值
        字符编码：将字符串转数字
            ——> Ebcdic 
            ——> ASCII（美国信息安全交换码,128个编码）
            ——> ISO-8859-1（对ASCLL的扩充） 
            ——> GB2312（引入了汉字编码，汉字占两个字节）
            ——> GBK（对GB2312的扩充）
            ——>GB18030（中文更加广泛）
            ——>Unicode（为了统一全国各地的编码规范，我们常用的UTF-8）
        自己设计编码（a=1,b=2,c=3,......）：
            方案一：数字相加，容易造成数据的覆盖，会有很多的单词最终的下标相同的
            方案二：幂的连乘，基本保证了唯一性，但是如果单词很长时，那麽得到的数字会相当的庞大，甚至超过数组的最大创建长度，即使可以创建，也会造成严重的空间浪费
    哈希化引入
        现在需要一种压缩方法，把幂的连乘方案得到的巨大整数范围压缩到可接受的数组范围中
            多大的数组合适？两倍的大小
            如何压缩？取余操作，index = largeNumber(数字的范围) % smallNumber(要压缩的范围)
    概念：
        哈希化：将大数字转换成数组范围内下标的过程称为哈希化
        哈希函数：我们将单词转换成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数我们称之为哈希函数
        哈希表：最终将数据插入到的这个数组，对整个结构的封装，我们称为哈希表
    冲突：尽管50000个单词我们使用100000个位置存储，并且通过一种相对比较好的哈希函数来完成，但是依然有可能发生冲突（比如：melioration获取下标时，发现这个下标位置已经存在一个单词demystify）
    如何解决冲突？（面试常考***）
        链地址法（拉链法）：每个数组单元中存储的不再是一个特定的值，而是链表或数组，以供冲突时传入（JAVA的哈希表采用的是链地址法）
        开放地址法：寻找空白的单元格来添加重复的数据
            探索这个位置（空白的单元格）的三种方法：
                线性探测：线性探测就是从冲突位置+1开始一点点查找空的位置来放置重复元素
                    线性探测的问题：聚集
                    什么是聚集呢？比如在没有任何数据的时候插入23，24，25，26，27，那么意味着3，4，5，6，7的位置都有数据，这种一连串单元就叫聚集，聚集会影响哈希表性能（插入查询删除都会有影响），比如我们插入33，会发现连续的单元都不允许我们添加数据。二次探测解决了这个问题
                二次探测：对步长进行了优化，比如从x开始，x+1^2,x+2^2,x+3^3......,效率比线性探测高，但会产生步长不一致的聚集
                再哈希化：
                    把关键字用另外一个哈希函数，再做一次哈希化，用这次哈希化的结果作为步长，
                    不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列，
                    对于指定的关键字，步长在整个探测过程当中是不变的，不过不同的关键字使用不同的步长
                    和第一个哈希函数不同，不能输出为0
                    计算机专家已设计出一种很好的哈希函数：stepSize = constant - (key % constant) ,其中constant是质数，且小于数组的容量
    哈希化的效率：
        在冲突的情况下与探测步长有关，步长与与装填因子有关（装填因子loadFactory = 总数据项 / 哈希表长度）装填因子越大，探测步长越长，效率越低，开放地址发填充因子最大是1，链地址法可以大于1，但是越到后面效率越低（数组或链表过长）
        开放地址发，线性探测 < 二次探测、再哈希化，指数增长，不太平稳；链地址法，线性增长，相对平稳，因此开发中常用链地址法
    优秀的哈希函数：快速的计算（尽量少用乘法和除法），均匀的分布（产生冲突时，将元素映射到不同的位置，在表中均匀分布）
        计算哈希值的优化：
            cats = 3*27^3+1*27^2+20*27+17 = 60337,这里乘法较多，我们可以在此做优化，利用霍纳法则（秦九韶算法：((..((anx + an-1)x + an-2)x + an-3)..)x + a1)x + a0)）将乘法尽可能的减少。
            哈希表的长度尽量使用质数（避免冲突）
    哈希表的扩容：
        为什莫需要扩容？在使用链地址法时。loadFactory可以大于1，所以这个哈希表可以无限的插入新数据，但是随着数据量的增多，每一个index对应的链表就会越来越长，也就造成了效率的降低，所以在适当情况对数组进行扩容两倍
        如何进行扩容？在loadFactory > 0.75时将数组的长度变为原来的两倍，在loadFactory < 0.25时进行缩容